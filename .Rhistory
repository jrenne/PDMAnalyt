all_q_t  <- matrix(q,nb_states,nb_eps*nb_m)
all_rr_tp1 <- all_q_t * all_zeta_tp1 * (all_d_t - chi * all_zeta_t * all_d_t_1) +
chi * all_zeta_tp1 * all_rr_t
all_d_tp1  <- all_zeta_tp1 * all_d_t - beta * (all_d_t - d_star) -
all_eta_tp1 + all_rr_tp1
# Match the previous states to the closest ones in the grid
indicators_d_tp1   <- apply(all_d_tp1,   c(1,2),function(x){which((x-all_d )^2==min((x-all_d )^2))[1]})
indicators_rr_tp1  <- apply(all_rr_tp1,  c(1,2),function(x){which((x-all_rr)^2==min((x-all_rr)^2))[1]})
indicators_x <- indicators_d_tp1 + (indicators_d_t - 1) * nb_grid_d +
(indicators_rr_tp1 - 1) * nb_grid_d^2 +
(indicators_m_tp1 - 1) * nb_grid_d^2 * nb_grid_rr
all_lambdas   <- pmax(beta * (all_d_t - d_star) + all_eta_tp1 - s_star,0)
all_proba_def <- 1 - exp(- alpha * all_lambdas)
# Compute right-hand side of the equation, conditional on varepsilon:
all_q_tp1 <- matrix(q[c(indicators_x)],nb_states,nb_eps*nb_m)
E <- exp(all_f_tp1) * ((1 + all_q_tp1)/(1 + all_q_tp1 - chi) +
all_proba_def * (exp(nu)*RR*all_OnepChiPstar -
(1 + all_q_tp1)/(1 + all_q_tp1 - chi)))
Q <- (chi - 1 + 1/E) * Probas
q <- apply(Q,1,sum) # update q
# update all_q matrix:
all_q_t  <- matrix(q,nb_states,nb_eps*nb_m)
all_rr_tp1 <- all_q_t * all_zeta_tp1 * (all_d_t - chi * all_zeta_t * all_d_t_1) +
chi * all_zeta_tp1 * all_rr_t
all_d_tp1  <- all_zeta_tp1 * all_d_t - beta * (all_d_t - d_star) -
all_eta_tp1 + all_rr_tp1
# Match the previous states to the closest ones in the grid
indicators_d_tp1   <- apply(all_d_tp1,   c(1,2),function(x){which((x-all_d )^2==min((x-all_d )^2))[1]})
indicators_rr_tp1  <- apply(all_rr_tp1,  c(1,2),function(x){which((x-all_rr)^2==min((x-all_rr)^2))[1]})
indicators_x <- indicators_d_tp1 + (indicators_d_t - 1) * nb_grid_d +
(indicators_rr_tp1 - 1) * nb_grid_d^2 +
(indicators_m_tp1 - 1) * nb_grid_d^2 * nb_grid_rr
all_lambdas   <- pmax(beta * (all_d_t - d_star) + all_eta_tp1 - s_star,0)
all_proba_def <- 1 - exp(- alpha * all_lambdas)
# Compute right-hand side of the equation, conditional on varepsilon:
all_q_tp1 <- matrix(q[c(indicators_x)],nb_states,nb_eps*nb_m)
E <- exp(all_f_tp1) * ((1 + all_q_tp1)/(1 + all_q_tp1 - chi) +
all_proba_def * (exp(nu)*RR*all_OnepChiPstar -
(1 + all_q_tp1)/(1 + all_q_tp1 - chi)))
Q <- (chi - 1 + 1/E) * Probas
q <- apply(Q,1,sum) # update q
# update all_q matrix:
all_q_t  <- matrix(q,nb_states,nb_eps*nb_m)
all_rr_tp1 <- all_q_t * all_zeta_tp1 * (all_d_t - chi * all_zeta_t * all_d_t_1) +
chi * all_zeta_tp1 * all_rr_t
all_d_tp1  <- all_zeta_tp1 * all_d_t - beta * (all_d_t - d_star) -
all_eta_tp1 + all_rr_tp1
# Match the previous states to the closest ones in the grid
indicators_d_tp1   <- apply(all_d_tp1,   c(1,2),function(x){which((x-all_d )^2==min((x-all_d )^2))[1]})
indicators_rr_tp1  <- apply(all_rr_tp1,  c(1,2),function(x){which((x-all_rr)^2==min((x-all_rr)^2))[1]})
indicators_x <- indicators_d_tp1 + (indicators_d_t - 1) * nb_grid_d +
(indicators_rr_tp1 - 1) * nb_grid_d^2 +
(indicators_m_tp1 - 1) * nb_grid_d^2 * nb_grid_rr
all_lambdas   <- pmax(beta * (all_d_t - d_star) + all_eta_tp1 - s_star,0)
all_proba_def <- 1 - exp(- alpha * all_lambdas)
# Compute right-hand side of the equation, conditional on varepsilon:
all_q_tp1 <- matrix(q[c(indicators_x)],nb_states,nb_eps*nb_m)
E <- exp(all_f_tp1) * ((1 + all_q_tp1)/(1 + all_q_tp1 - chi) +
all_proba_def * (exp(nu)*RR*all_OnepChiPstar -
(1 + all_q_tp1)/(1 + all_q_tp1 - chi)))
Q <- (chi - 1 + 1/E) * Probas
q <- apply(Q,1,sum) # update q
# update all_q matrix:
all_q_t  <- matrix(q,nb_states,nb_eps*nb_m)
all_rr_tp1 <- all_q_t * all_zeta_tp1 * (all_d_t - chi * all_zeta_t * all_d_t_1) +
chi * all_zeta_tp1 * all_rr_t
all_d_tp1  <- all_zeta_tp1 * all_d_t - beta * (all_d_t - d_star) -
all_eta_tp1 + all_rr_tp1
# Match the previous states to the closest ones in the grid
indicators_d_tp1   <- apply(all_d_tp1,   c(1,2),function(x){which((x-all_d )^2==min((x-all_d )^2))[1]})
indicators_rr_tp1  <- apply(all_rr_tp1,  c(1,2),function(x){which((x-all_rr)^2==min((x-all_rr)^2))[1]})
indicators_x <- indicators_d_tp1 + (indicators_d_t - 1) * nb_grid_d +
(indicators_rr_tp1 - 1) * nb_grid_d^2 +
(indicators_m_tp1 - 1) * nb_grid_d^2 * nb_grid_rr
all_lambdas   <- pmax(beta * (all_d_t - d_star) + all_eta_tp1 - s_star,0)
all_proba_def <- 1 - exp(- alpha * all_lambdas)
# Compute right-hand side of the equation, conditional on varepsilon:
all_q_tp1 <- matrix(q[c(indicators_x)],nb_states,nb_eps*nb_m)
E <- exp(all_f_tp1) * ((1 + all_q_tp1)/(1 + all_q_tp1 - chi) +
all_proba_def * (exp(nu)*RR*all_OnepChiPstar -
(1 + all_q_tp1)/(1 + all_q_tp1 - chi)))
Q <- (chi - 1 + 1/E) * Probas
q <- apply(Q,1,sum) # update q
q
all_lambdas
all_proba_def
indicators_x
q[c(indicators_x)]
q
indicators_x
all_q_tp1
(1 + all_q_tp1)/(1 + all_q_tp1 - chi)
sigma_eps <- 0
all_eps
all_eps <- 0
proba_eps <- 1
nb_grid_d  <- dim(all_d)[1]
nb_grid_rr <- dim(all_rr)[1]
nb_m       <- dim(Model$Omega)[1]
nb_states  <- nb_grid_d^2 * nb_grid_rr * nb_m
nb_eps     <- dim(all_eps)[1]
vec_ones_d   <- matrix(1,nb_grid_d)
vec_ones_rr  <- matrix(1,nb_grid_rr)
vec_ones_m   <- matrix(1,nb_m)
vec_ones_eps <- matrix(1,nb_eps)
nb_eps
nb_eps <- 1
vec_ones_d   <- matrix(1,nb_grid_d)
vec_ones_rr  <- matrix(1,nb_grid_rr)
vec_ones_m   <- matrix(1,nb_m)
vec_ones_eps <- matrix(1,nb_eps)
kappa_pi <- Model$kappa_pi
kappa_y  <- Model$kappa_y
nu_pi    <- Model$nu_pi
nu_y     <- Model$nu_y
mu_pi    <- Model$mu_pi
mu_y     <- Model$mu_y
mu_eta   <- Model$mu_eta
Gamma    <- Model$gamma
delta    <- Model$delta
Dy_bar   <- Model$Dy_bar
Pi_bar   <- Model$Pi_bar
beta     <- Model$beta
chi      <- Model$chi
Omega    <- Model$Omega
d_star   <- Model$d_star
alpha    <- Model$alpha
s_star   <- Model$s_star
RR       <- Model$RR
sigma_eps <- Model$sigma_eps
# Compute stationary macro distribution:
Omega_2h <- t(Omega)
for(i in 1:10){
Omega_2h <- Omega_2h %*% Omega_2h
}
stat_distri <- Omega_2h[,1]
# s.d.f. specification (associated with composite index)
res_SDF <- compute_SDF(Model)
mu_f0   <- res_SDF$mu_f0
mu_f1   <- res_SDF$mu_f1
nu <- - Gamma * nu_y + (kappa_pi - 1) * nu_pi + kappa_y * nu_y
d     <- vec_ones_m  %x% vec_ones_rr %x% vec_ones_d %x% all_d
d_1   <- vec_ones_m  %x% vec_ones_rr %x% all_d      %x% vec_ones_d
rr    <- vec_ones_m  %x% all_rr      %x% vec_ones_d %x% vec_ones_d
Pi    <- mu_pi       %x% vec_ones_rr %x% vec_ones_d %x% vec_ones_d
Dy    <- mu_y        %x% vec_ones_rr %x% vec_ones_d %x% vec_ones_d
s_m   <- mu_eta      %x% vec_ones_rr %x% vec_ones_d %x% vec_ones_d
all_d_t     <- matrix(d,   nb_states,nb_eps*nb_m)
all_d_t_1   <- matrix(d_1, nb_states,nb_eps*nb_m)
all_rr_t    <- matrix(rr,  nb_states,nb_eps*nb_m)
all_Pi_t    <- matrix(Pi,  nb_states,nb_eps*nb_m)
all_Dy_t    <- matrix(Dy,  nb_states,nb_eps*nb_m)
all_s_m_t   <- matrix(s_m, nb_states,nb_eps*nb_m)
Dlast <- diag(c(exp(mu_f1)))
Dbetw <- diag(c(exp(mu_f0 + mu_f1)))
D1rst <- diag(c(exp(mu_f0)))
Mlast <- Dlast %*% t(Omega)
Mbetw <- Dbetw %*% t(Omega)
M1rst <- D1rst
Pstar = t(vec_ones_m) %*% Mlast %*% solve(diag(nb_m) - chi * Mbetw) %*% M1rst
OnepChiPstar <- 1 + chi * Pstar
avg_LT_price <- c(OnepChiPstar %*% stat_distri)
rstar <- t(1/Pstar - 1 + chi) # will be used to initialize q
#r_bar <- 1/avg_LT_price - 1 + chi
r_bar <- ((1 - chi) * sum(OnepChiPstar * stat_distri) - 1) / (1 - sum(OnepChiPstar * stat_distri)) ;
all_eps_tp1      <- t(matrix(vec_ones_m   %x% all_eps, nb_eps * nb_m,nb_states))
all_Pi_tp1       <- t(matrix(mu_pi        %x% vec_ones_eps, nb_eps * nb_m,nb_states))
all_Dy_tp1       <- t(matrix(mu_y         %x% vec_ones_eps, nb_eps * nb_m,nb_states))
all_f_tp1        <- t(matrix(mu_f1        %x% vec_ones_eps, nb_eps * nb_m,nb_states)) +
matrix(mu_f0 %x% vec_ones_rr %x% vec_ones_d %x% vec_ones_d,nb_states,nb_eps * nb_m)
all_OnepChiPstar <- t(matrix(OnepChiPstar %x% vec_ones_eps, nb_eps * nb_m,nb_states))
all_eta_tp1      <- all_eps_tp1 +
t(matrix(mu_eta %x% vec_ones_eps, nb_eps * nb_m,nb_states)) - all_s_m_t
# Probas <- (Omega %x% matrix(1/nb_eps,1,nb_eps)) %x%
#   matrix(1,nb_grid_d^2*nb_grid_rr,1)
Probas <- (Omega %x% t(proba_eps)) %x% matrix(1,nb_grid_d^2*nb_grid_rr,1)
q   <- (rstar + .001) %x% matrix(1,nb_grid_d^2*nb_grid_rr,1)
q0  <- (rstar + .00 ) %x% matrix(1,nb_grid_d^2*nb_grid_rr,1) # risk-free rate
q_1 <- q # this is used to compute chges in the recursions
all_zeta_t   <- exp((kappa_pi - 1) * all_Pi_t   + (kappa_y - 1) * all_Dy_t)
all_zeta_tp1 <- exp((kappa_pi - 1) * all_Pi_tp1 + (kappa_y - 1) * all_Dy_tp1)
indicators_d_t   <- matrix(1:nb_grid_d,nb_states,nb_eps*nb_m)
indicators_m_tp1 <- t(matrix((1:nb_m) %x% vec_ones_eps,nb_m*nb_eps,nb_states))
indicators_x <- NULL
all_proba_def = NULL
# update all_q matrix:
all_q_t  <- matrix(q,nb_states,nb_eps*nb_m)
all_rr_tp1 <- all_q_t * all_zeta_tp1 * (all_d_t - chi * all_zeta_t * all_d_t_1) +
chi * all_zeta_tp1 * all_rr_t
all_d_tp1  <- all_zeta_tp1 * all_d_t - beta * (all_d_t - d_star) -
all_eta_tp1 + all_rr_tp1
# Match the previous states to the closest ones in the grid
indicators_d_tp1   <- apply(all_d_tp1,   c(1,2),function(x){which((x-all_d )^2==min((x-all_d )^2))[1]})
indicators_rr_tp1  <- apply(all_rr_tp1,  c(1,2),function(x){which((x-all_rr)^2==min((x-all_rr)^2))[1]})
indicators_x <- indicators_d_tp1 + (indicators_d_t - 1) * nb_grid_d +
(indicators_rr_tp1 - 1) * nb_grid_d^2 +
(indicators_m_tp1 - 1) * nb_grid_d^2 * nb_grid_rr
all_lambdas   <- pmax(beta * (all_d_t - d_star) + all_eta_tp1 - s_star,0)
all_proba_def <- 1 - exp(- alpha * all_lambdas)
# Compute right-hand side of the equation, conditional on varepsilon:
all_q_tp1 <- matrix(q[c(indicators_x)],nb_states,nb_eps*nb_m)
E <- exp(all_f_tp1) * ((1 + all_q_tp1)/(1 + all_q_tp1 - chi) +
all_proba_def * (exp(nu)*RR*all_OnepChiPstar -
(1 + all_q_tp1)/(1 + all_q_tp1 - chi)))
Q <- (chi - 1 + 1/E) * Probas
q <- apply(Q,1,sum) # update q
q
indicators_x
all_q_t  <- matrix(q,nb_states,nb_eps*nb_m)
all_rr_tp1 <- all_q_t * all_zeta_tp1 * (all_d_t - chi * all_zeta_t * all_d_t_1) +
chi * all_zeta_tp1 * all_rr_t
all_d_tp1  <- all_zeta_tp1 * all_d_t - beta * (all_d_t - d_star) -
all_eta_tp1 + all_rr_tp1
# Match the previous states to the closest ones in the grid
indicators_d_tp1   <- apply(all_d_tp1,   c(1,2),function(x){which((x-all_d )^2==min((x-all_d )^2))[1]})
indicators_rr_tp1  <- apply(all_rr_tp1,  c(1,2),function(x){which((x-all_rr)^2==min((x-all_rr)^2))[1]})
indicators_x <- indicators_d_tp1 + (indicators_d_t - 1) * nb_grid_d +
(indicators_rr_tp1 - 1) * nb_grid_d^2 +
(indicators_m_tp1 - 1) * nb_grid_d^2 * nb_grid_rr
all_lambdas   <- pmax(beta * (all_d_t - d_star) + all_eta_tp1 - s_star,0)
all_proba_def <- 1 - exp(- alpha * all_lambdas)
# Compute right-hand side of the equation, conditional on varepsilon:
all_q_tp1 <- matrix(q[c(indicators_x)],nb_states,nb_eps*nb_m)
E <- exp(all_f_tp1) * ((1 + all_q_tp1)/(1 + all_q_tp1 - chi) +
all_proba_def * (exp(nu)*RR*all_OnepChiPstar -
(1 + all_q_tp1)/(1 + all_q_tp1 - chi)))
Q <- (chi - 1 + 1/E) * Probas
q <- apply(Q,1,sum) # update q
all_q_t  <- matrix(q,nb_states,nb_eps*nb_m)
all_rr_tp1 <- all_q_t * all_zeta_tp1 * (all_d_t - chi * all_zeta_t * all_d_t_1) +
chi * all_zeta_tp1 * all_rr_t
all_d_tp1  <- all_zeta_tp1 * all_d_t - beta * (all_d_t - d_star) -
all_eta_tp1 + all_rr_tp1
# Match the previous states to the closest ones in the grid
indicators_d_tp1   <- apply(all_d_tp1,   c(1,2),function(x){which((x-all_d )^2==min((x-all_d )^2))[1]})
indicators_rr_tp1  <- apply(all_rr_tp1,  c(1,2),function(x){which((x-all_rr)^2==min((x-all_rr)^2))[1]})
indicators_x <- indicators_d_tp1 + (indicators_d_t - 1) * nb_grid_d +
(indicators_rr_tp1 - 1) * nb_grid_d^2 +
(indicators_m_tp1 - 1) * nb_grid_d^2 * nb_grid_rr
all_lambdas   <- pmax(beta * (all_d_t - d_star) + all_eta_tp1 - s_star,0)
all_proba_def <- 1 - exp(- alpha * all_lambdas)
# Compute right-hand side of the equation, conditional on varepsilon:
all_q_tp1 <- matrix(q[c(indicators_x)],nb_states,nb_eps*nb_m)
E <- exp(all_f_tp1) * ((1 + all_q_tp1)/(1 + all_q_tp1 - chi) +
all_proba_def * (exp(nu)*RR*all_OnepChiPstar -
(1 + all_q_tp1)/(1 + all_q_tp1 - chi)))
Q <- (chi - 1 + 1/E) * Probas
q <- apply(Q,1,sum) # update q
all_q_t  <- matrix(q,nb_states,nb_eps*nb_m)
all_rr_tp1 <- all_q_t * all_zeta_tp1 * (all_d_t - chi * all_zeta_t * all_d_t_1) +
chi * all_zeta_tp1 * all_rr_t
all_d_tp1  <- all_zeta_tp1 * all_d_t - beta * (all_d_t - d_star) -
all_eta_tp1 + all_rr_tp1
# Match the previous states to the closest ones in the grid
indicators_d_tp1   <- apply(all_d_tp1,   c(1,2),function(x){which((x-all_d )^2==min((x-all_d )^2))[1]})
indicators_rr_tp1  <- apply(all_rr_tp1,  c(1,2),function(x){which((x-all_rr)^2==min((x-all_rr)^2))[1]})
indicators_x <- indicators_d_tp1 + (indicators_d_t - 1) * nb_grid_d +
(indicators_rr_tp1 - 1) * nb_grid_d^2 +
(indicators_m_tp1 - 1) * nb_grid_d^2 * nb_grid_rr
all_lambdas   <- pmax(beta * (all_d_t - d_star) + all_eta_tp1 - s_star,0)
all_proba_def <- 1 - exp(- alpha * all_lambdas)
# Compute right-hand side of the equation, conditional on varepsilon:
all_q_tp1 <- matrix(q[c(indicators_x)],nb_states,nb_eps*nb_m)
E <- exp(all_f_tp1) * ((1 + all_q_tp1)/(1 + all_q_tp1 - chi) +
all_proba_def * (exp(nu)*RR*all_OnepChiPstar -
(1 + all_q_tp1)/(1 + all_q_tp1 - chi)))
Q <- (chi - 1 + 1/E) * Probas
q <- apply(Q,1,sum) # update q
q
Probas
Model$Omega
all_f_tp1
apply(Proba,1,sum)
apply(Probas,1,sum)
q   <- (rstar + .001) %x% matrix(1,nb_grid_d^2*nb_grid_rr,1)
q0  <- (rstar + .00 ) %x% matrix(1,nb_grid_d^2*nb_grid_rr,1) # risk-free rate
q_1 <- q # this is used to compute chges in the recursions
all_zeta_t   <- exp((kappa_pi - 1) * all_Pi_t   + (kappa_y - 1) * all_Dy_t)
all_zeta_tp1 <- exp((kappa_pi - 1) * all_Pi_tp1 + (kappa_y - 1) * all_Dy_tp1)
indicators_d_t   <- matrix(1:nb_grid_d,nb_states,nb_eps*nb_m)
indicators_m_tp1 <- t(matrix((1:nb_m) %x% vec_ones_eps,nb_m*nb_eps,nb_states))
indicators_x <- NULL
all_proba_def = NULL
# update all_q matrix:
all_q_t  <- matrix(q,nb_states,nb_eps*nb_m)
all_rr_tp1 <- all_q_t * all_zeta_tp1 * (all_d_t - chi * all_zeta_t * all_d_t_1) +
chi * all_zeta_tp1 * all_rr_t
all_d_tp1  <- all_zeta_tp1 * all_d_t - beta * (all_d_t - d_star) -
all_eta_tp1 + all_rr_tp1
# Match the previous states to the closest ones in the grid
indicators_d_tp1   <- apply(all_d_tp1,   c(1,2),function(x){which((x-all_d )^2==min((x-all_d )^2))[1]})
indicators_rr_tp1  <- apply(all_rr_tp1,  c(1,2),function(x){which((x-all_rr)^2==min((x-all_rr)^2))[1]})
indicators_x <- indicators_d_tp1 + (indicators_d_t - 1) * nb_grid_d +
(indicators_rr_tp1 - 1) * nb_grid_d^2 +
(indicators_m_tp1 - 1) * nb_grid_d^2 * nb_grid_rr
all_lambdas   <- pmax(beta * (all_d_t - d_star) + all_eta_tp1 - s_star,0)
all_proba_def <- 1 - exp(- alpha * all_lambdas)
# Compute right-hand side of the equation, conditional on varepsilon:
all_q_tp1 <- matrix(q[c(indicators_x)],nb_states,nb_eps*nb_m)
E <- exp(all_f_tp1) * ((1 + all_q_tp1)/(1 + all_q_tp1 - chi) +
all_proba_def * (exp(nu)*RR*all_OnepChiPstar -
(1 + all_q_tp1)/(1 + all_q_tp1 - chi)))
q <- chi - 1 + 1/apply(E * Probas,1,sum)
# update all_q matrix:
all_q_t  <- matrix(q,nb_states,nb_eps*nb_m)
all_rr_tp1 <- all_q_t * all_zeta_tp1 * (all_d_t - chi * all_zeta_t * all_d_t_1) +
chi * all_zeta_tp1 * all_rr_t
all_d_tp1  <- all_zeta_tp1 * all_d_t - beta * (all_d_t - d_star) -
all_eta_tp1 + all_rr_tp1
# Match the previous states to the closest ones in the grid
indicators_d_tp1   <- apply(all_d_tp1,   c(1,2),function(x){which((x-all_d )^2==min((x-all_d )^2))[1]})
indicators_rr_tp1  <- apply(all_rr_tp1,  c(1,2),function(x){which((x-all_rr)^2==min((x-all_rr)^2))[1]})
indicators_x <- indicators_d_tp1 + (indicators_d_t - 1) * nb_grid_d +
(indicators_rr_tp1 - 1) * nb_grid_d^2 +
(indicators_m_tp1 - 1) * nb_grid_d^2 * nb_grid_rr
all_lambdas   <- pmax(beta * (all_d_t - d_star) + all_eta_tp1 - s_star,0)
all_proba_def <- 1 - exp(- alpha * all_lambdas)
# Compute right-hand side of the equation, conditional on varepsilon:
all_q_tp1 <- matrix(q[c(indicators_x)],nb_states,nb_eps*nb_m)
E <- exp(all_f_tp1) * ((1 + all_q_tp1)/(1 + all_q_tp1 - chi) +
all_proba_def * (exp(nu)*RR*all_OnepChiPstar -
(1 + all_q_tp1)/(1 + all_q_tp1 - chi)))
q <- chi - 1 + 1/apply(E * Probas,1,sum)
# update all_q matrix:
all_q_t  <- matrix(q,nb_states,nb_eps*nb_m)
all_rr_tp1 <- all_q_t * all_zeta_tp1 * (all_d_t - chi * all_zeta_t * all_d_t_1) +
chi * all_zeta_tp1 * all_rr_t
all_d_tp1  <- all_zeta_tp1 * all_d_t - beta * (all_d_t - d_star) -
all_eta_tp1 + all_rr_tp1
# Match the previous states to the closest ones in the grid
indicators_d_tp1   <- apply(all_d_tp1,   c(1,2),function(x){which((x-all_d )^2==min((x-all_d )^2))[1]})
indicators_rr_tp1  <- apply(all_rr_tp1,  c(1,2),function(x){which((x-all_rr)^2==min((x-all_rr)^2))[1]})
indicators_x <- indicators_d_tp1 + (indicators_d_t - 1) * nb_grid_d +
(indicators_rr_tp1 - 1) * nb_grid_d^2 +
(indicators_m_tp1 - 1) * nb_grid_d^2 * nb_grid_rr
all_lambdas   <- pmax(beta * (all_d_t - d_star) + all_eta_tp1 - s_star,0)
all_proba_def <- 1 - exp(- alpha * all_lambdas)
# Compute right-hand side of the equation, conditional on varepsilon:
all_q_tp1 <- matrix(q[c(indicators_x)],nb_states,nb_eps*nb_m)
E <- exp(all_f_tp1) * ((1 + all_q_tp1)/(1 + all_q_tp1 - chi) +
all_proba_def * (exp(nu)*RR*all_OnepChiPstar -
(1 + all_q_tp1)/(1 + all_q_tp1 - chi)))
q <- chi - 1 + 1/apply(E * Probas,1,sum)
# update all_q matrix:
all_q_t  <- matrix(q,nb_states,nb_eps*nb_m)
all_rr_tp1 <- all_q_t * all_zeta_tp1 * (all_d_t - chi * all_zeta_t * all_d_t_1) +
chi * all_zeta_tp1 * all_rr_t
all_d_tp1  <- all_zeta_tp1 * all_d_t - beta * (all_d_t - d_star) -
all_eta_tp1 + all_rr_tp1
# Match the previous states to the closest ones in the grid
indicators_d_tp1   <- apply(all_d_tp1,   c(1,2),function(x){which((x-all_d )^2==min((x-all_d )^2))[1]})
indicators_rr_tp1  <- apply(all_rr_tp1,  c(1,2),function(x){which((x-all_rr)^2==min((x-all_rr)^2))[1]})
indicators_x <- indicators_d_tp1 + (indicators_d_t - 1) * nb_grid_d +
(indicators_rr_tp1 - 1) * nb_grid_d^2 +
(indicators_m_tp1 - 1) * nb_grid_d^2 * nb_grid_rr
all_lambdas   <- pmax(beta * (all_d_t - d_star) + all_eta_tp1 - s_star,0)
all_proba_def <- 1 - exp(- alpha * all_lambdas)
# Compute right-hand side of the equation, conditional on varepsilon:
all_q_tp1 <- matrix(q[c(indicators_x)],nb_states,nb_eps*nb_m)
E <- exp(all_f_tp1) * ((1 + all_q_tp1)/(1 + all_q_tp1 - chi) +
all_proba_def * (exp(nu)*RR*all_OnepChiPstar -
(1 + all_q_tp1)/(1 + all_q_tp1 - chi)))
q <- chi - 1 + 1/apply(E * Probas,1,sum)
# update all_q matrix:
all_q_t  <- matrix(q,nb_states,nb_eps*nb_m)
all_rr_tp1 <- all_q_t * all_zeta_tp1 * (all_d_t - chi * all_zeta_t * all_d_t_1) +
chi * all_zeta_tp1 * all_rr_t
all_d_tp1  <- all_zeta_tp1 * all_d_t - beta * (all_d_t - d_star) -
all_eta_tp1 + all_rr_tp1
# Match the previous states to the closest ones in the grid
indicators_d_tp1   <- apply(all_d_tp1,   c(1,2),function(x){which((x-all_d )^2==min((x-all_d )^2))[1]})
indicators_rr_tp1  <- apply(all_rr_tp1,  c(1,2),function(x){which((x-all_rr)^2==min((x-all_rr)^2))[1]})
indicators_x <- indicators_d_tp1 + (indicators_d_t - 1) * nb_grid_d +
(indicators_rr_tp1 - 1) * nb_grid_d^2 +
(indicators_m_tp1 - 1) * nb_grid_d^2 * nb_grid_rr
all_lambdas   <- pmax(beta * (all_d_t - d_star) + all_eta_tp1 - s_star,0)
all_proba_def <- 1 - exp(- alpha * all_lambdas)
# Compute right-hand side of the equation, conditional on varepsilon:
all_q_tp1 <- matrix(q[c(indicators_x)],nb_states,nb_eps*nb_m)
E <- exp(all_f_tp1) * ((1 + all_q_tp1)/(1 + all_q_tp1 - chi) +
all_proba_def * (exp(nu)*RR*all_OnepChiPstar -
(1 + all_q_tp1)/(1 + all_q_tp1 - chi)))
q <- chi - 1 + 1/apply(E * Probas,1,sum)
# update all_q matrix:
all_q_t  <- matrix(q,nb_states,nb_eps*nb_m)
all_rr_tp1 <- all_q_t * all_zeta_tp1 * (all_d_t - chi * all_zeta_t * all_d_t_1) +
chi * all_zeta_tp1 * all_rr_t
all_d_tp1  <- all_zeta_tp1 * all_d_t - beta * (all_d_t - d_star) -
all_eta_tp1 + all_rr_tp1
# Match the previous states to the closest ones in the grid
indicators_d_tp1   <- apply(all_d_tp1,   c(1,2),function(x){which((x-all_d )^2==min((x-all_d )^2))[1]})
indicators_rr_tp1  <- apply(all_rr_tp1,  c(1,2),function(x){which((x-all_rr)^2==min((x-all_rr)^2))[1]})
indicators_x <- indicators_d_tp1 + (indicators_d_t - 1) * nb_grid_d +
(indicators_rr_tp1 - 1) * nb_grid_d^2 +
(indicators_m_tp1 - 1) * nb_grid_d^2 * nb_grid_rr
all_lambdas   <- pmax(beta * (all_d_t - d_star) + all_eta_tp1 - s_star,0)
all_proba_def <- 1 - exp(- alpha * all_lambdas)
# Compute right-hand side of the equation, conditional on varepsilon:
all_q_tp1 <- matrix(q[c(indicators_x)],nb_states,nb_eps*nb_m)
E <- exp(all_f_tp1) * ((1 + all_q_tp1)/(1 + all_q_tp1 - chi) +
all_proba_def * (exp(nu)*RR*all_OnepChiPstar -
(1 + all_q_tp1)/(1 + all_q_tp1 - chi)))
q <- chi - 1 + 1/apply(E * Probas,1,sum)
# update all_q matrix:
all_q_t  <- matrix(q,nb_states,nb_eps*nb_m)
all_rr_tp1 <- all_q_t * all_zeta_tp1 * (all_d_t - chi * all_zeta_t * all_d_t_1) +
chi * all_zeta_tp1 * all_rr_t
all_d_tp1  <- all_zeta_tp1 * all_d_t - beta * (all_d_t - d_star) -
all_eta_tp1 + all_rr_tp1
# Match the previous states to the closest ones in the grid
indicators_d_tp1   <- apply(all_d_tp1,   c(1,2),function(x){which((x-all_d )^2==min((x-all_d )^2))[1]})
indicators_rr_tp1  <- apply(all_rr_tp1,  c(1,2),function(x){which((x-all_rr)^2==min((x-all_rr)^2))[1]})
indicators_x <- indicators_d_tp1 + (indicators_d_t - 1) * nb_grid_d +
(indicators_rr_tp1 - 1) * nb_grid_d^2 +
(indicators_m_tp1 - 1) * nb_grid_d^2 * nb_grid_rr
all_lambdas   <- pmax(beta * (all_d_t - d_star) + all_eta_tp1 - s_star,0)
all_proba_def <- 1 - exp(- alpha * all_lambdas)
# Compute right-hand side of the equation, conditional on varepsilon:
all_q_tp1 <- matrix(q[c(indicators_x)],nb_states,nb_eps*nb_m)
E <- exp(all_f_tp1) * ((1 + all_q_tp1)/(1 + all_q_tp1 - chi) +
all_proba_def * (exp(nu)*RR*all_OnepChiPstar -
(1 + all_q_tp1)/(1 + all_q_tp1 - chi)))
q <- chi - 1 + 1/apply(E * Probas,1,sum)
# update all_q matrix:
all_q_t  <- matrix(q,nb_states,nb_eps*nb_m)
all_rr_tp1 <- all_q_t * all_zeta_tp1 * (all_d_t - chi * all_zeta_t * all_d_t_1) +
chi * all_zeta_tp1 * all_rr_t
all_d_tp1  <- all_zeta_tp1 * all_d_t - beta * (all_d_t - d_star) -
all_eta_tp1 + all_rr_tp1
# Match the previous states to the closest ones in the grid
indicators_d_tp1   <- apply(all_d_tp1,   c(1,2),function(x){which((x-all_d )^2==min((x-all_d )^2))[1]})
indicators_rr_tp1  <- apply(all_rr_tp1,  c(1,2),function(x){which((x-all_rr)^2==min((x-all_rr)^2))[1]})
indicators_x <- indicators_d_tp1 + (indicators_d_t - 1) * nb_grid_d +
(indicators_rr_tp1 - 1) * nb_grid_d^2 +
(indicators_m_tp1 - 1) * nb_grid_d^2 * nb_grid_rr
all_lambdas   <- pmax(beta * (all_d_t - d_star) + all_eta_tp1 - s_star,0)
all_proba_def <- 1 - exp(- alpha * all_lambdas)
# Compute right-hand side of the equation, conditional on varepsilon:
all_q_tp1 <- matrix(q[c(indicators_x)],nb_states,nb_eps*nb_m)
E <- exp(all_f_tp1) * ((1 + all_q_tp1)/(1 + all_q_tp1 - chi) +
all_proba_def * (exp(nu)*RR*all_OnepChiPstar -
(1 + all_q_tp1)/(1 + all_q_tp1 - chi)))
q <- chi - 1 + 1/apply(E * Probas,1,sum)
q
rstar
Rcpp::sourceCpp("procedures/pricing_cpp.cpp")
res0_nominal <- solve_ToyModel(all_d,all_rr,all_eps,proba_eps,
Model,nb_iter = 10)
res0_nominal_notRcpp <- solve_ToyModel_notRcpp(all_d,all_rr,all_eps,proba_eps,
Model,nb_iter = 10)
source("~/Dropbox/Research/PDMAnalyt/make_grids.R", echo=TRUE)
source("~/Dropbox/Research/PDMAnalyt/Test_PDM.R", echo=TRUE)
source("~/Dropbox/Research/PDMAnalyt/Test_PDM.R", echo=TRUE)
source("~/Dropbox/Research/PDMAnalyt/Test_PDM.R", echo=TRUE)
res0_nominal$q[c(1,400,1000,8000)]
res0_nominal_notRcpp$q[c(1,400,1000,8000)]
dim(res0_nominal_notRcpp$q)
res0_nominal_notRcpp$q
dim(res0_nominalRcpp$q)
dim(res0_nominal$q)
length(res0_nominal_notRcpp$q)
source("~/Dropbox/Research/PDMAnalyt/Test_PDM.R", echo=TRUE)
res0_nominal$q
res0_nominal$q[c(1,400,1000,8000)]
res0_nominal_notRcpp$q[c(1,400,1000,8000)]
Model$mu_eta
Model$mu_y
res0_nominal$q
res0_nominal$q[c(1,400,1000,30000)]
res0_nominal_notRcpp$q[c(1,400,1000,30000)]
source("~/Dropbox/Research/PDMAnalyt/Test_PDM.R", echo=TRUE)
source("~/Dropbox/Research/PDMAnalyt/Test_PDM.R", echo=TRUE)
levels(as.factor(res0_nominal$q))
res0_nominal$rstar
source("~/Dropbox/Research/PDMAnalyt/Test_PDM.R", echo=TRUE)
source("~/Dropbox/Research/PDMAnalyt/estimation/run_estim.R", echo=TRUE)
SSpace <- make_StateSpace(Model)
SSpace <- make_StateSpace(Model)
res_SS <- make_StateSpace(Model)
M      <- res_SS$M
N      <- res_SS$N
F      <- res_SS$F
dates  <- res_SS$dates
res_KH <- KH_filter(F,M,N,Model$Omega)
fitted <- res_KH$ksi_matrix %*% t(M)
par(mfrow=c(2,3))
for(i in 1:dim(M)[1]){
plot(F[,i],type="l")
lines(fitted[,i],col="red")
}
plot(yds_nom,type="l",ylim=c(0,.08))
plot(avg_nom_yds,type="l",ylim=c(0,.08))
avg_nom_yds  <- t(stat_distri) %*% res_LTnominal_prices$all_LT_rth
avg_real_yds <- t(stat_distri) %*% res_LTreal_prices$all_LT_rth
plot(avg_nom_yds,type="l",ylim=c(0,.08))
lines(avg_real_yds,col="red")
avg_nom_yds
plot(c(avg_nom_yds),type="l",ylim=c(0,.08))
lines(c(avg_real_yds),col="red")
plot(c(avg_nom_yds),type="l",ylim=c(0,.1))
lines(c(avg_real_yds),col="red")
stat_distri <- compute_stat_distri(Model)
avg_nom_yds  <- t(stat_distri) %*% res_LTnominal_prices$all_LT_rth
avg_real_yds <- t(stat_distri) %*% res_LTreal_prices$all_LT_rth
plot(c(avg_nom_yds),type="l",ylim=c(0,.1))
lines(c(avg_real_yds),col="red")
plot(c(avg_nom_yds),type="l",ylim=c(0,.08))
lines(c(avg_real_yds),col="red")
source("~/Dropbox/Research/PDMAnalyt/estimation/run_estim.R", echo=TRUE)
source("~/Dropbox/Research/PDMAnalyt/estimation/run_estim.R", echo=TRUE)
source("~/Dropbox/Research/PDMAnalyt/Test_PDM.R", echo=TRUE)
source("~/Dropbox/Research/PDMAnalyt/calibrate_beta.R", echo=TRUE)
